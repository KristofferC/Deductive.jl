<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Assertion Proofs · Deductive Documentation</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><script src="../../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Deductive Documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Deductive Documentation</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Deductive</a></li><li><a class="tocitem" href="../../propositional_logic/">Propositional Logic</a></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../expressions/">Expressions</a></li><li><a class="tocitem" href="../proof_utilities/">Proof Utilities</a></li><li class="is-active"><a class="tocitem" href>Assertion Proofs</a><ul class="internal"><li><a class="tocitem" href="#Given-Goal-Proofs"><span>Given Goal Proofs</span></a></li><li><a class="tocitem" href="#Matching-Algorithms"><span>Matching Algorithms</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Internals</a></li><li class="is-active"><a href>Assertion Proofs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Assertion Proofs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ctrekker/Deductive.jl/blob/master/docs/src/internals/assertion_proofs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Assertion-Proofs"><a class="docs-heading-anchor" href="#Assertion-Proofs">Assertion Proofs</a><a id="Assertion-Proofs-1"></a><a class="docs-heading-anchor-permalink" href="#Assertion-Proofs" title="Permalink"></a></h1><p>Assertion proofs are a kind of proof structured in a manner where one starts with a set of statements they would like to prove in terms of another set of statements. Deductive makes this distinction so that a given-goal structure can be defined which describes such a system.</p><h2 id="Given-Goal-Proofs"><a class="docs-heading-anchor" href="#Given-Goal-Proofs">Given Goal Proofs</a><a id="Given-Goal-Proofs-1"></a><a class="docs-heading-anchor-permalink" href="#Given-Goal-Proofs" title="Permalink"></a></h2><p>Given-goal systems are useful for a number of reasons, such as allowing for clear meta-transformations like a contradictory or contrapositive system, better reflecting the underlying form which mathematical proofs usually fall under, and cutting down on search algorithm costs by utilizing inference rules as a means of statement transformation instead of replacement rules, which can be applied recursively to an expression tree rather than just the &quot;top&quot;.</p><article class="docstring"><header><a class="docstring-binding" id="Deductive.GivenGoal" href="#Deductive.GivenGoal"><code>Deductive.GivenGoal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GivenGoal(given::Set{AbstractExpression}, goal::Set{AbstractExpression})</code></pre><p>Initialize a structure representing a proof starting and ending point, with given and goal sets of expressions respectively. This structure on its own isn&#39;t enough to conduct a proof, however. A proof requires both a <code>GivenGoal</code> and a logical calculus which defines the allowed elementary operations on expressions. For example, if operating within propositional logic, see the  PropositionalCalculus definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ctrekker/Deductive.jl/blob/4b0dd6ee98b6e2afa555dfe3bcf769e4446552ba/src/assertion_proof.jl#L11-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Deductive.given" href="#Deductive.given"><code>Deductive.given</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">given(gg::GivenGoal)</code></pre><p>Returns the <code>given</code> part of a <a href="#Deductive.GivenGoal"><code>GivenGoal</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ctrekker/Deductive.jl/blob/4b0dd6ee98b6e2afa555dfe3bcf769e4446552ba/src/assertion_proof.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Deductive.goal" href="#Deductive.goal"><code>Deductive.goal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">goal(gg::GivenGoal)</code></pre><p>Returns the <code>goal</code> part of a <a href="#Deductive.GivenGoal"><code>GivenGoal</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ctrekker/Deductive.jl/blob/4b0dd6ee98b6e2afa555dfe3bcf769e4446552ba/src/assertion_proof.jl#L46-L50">source</a></section></article><h2 id="Matching-Algorithms"><a class="docs-heading-anchor" href="#Matching-Algorithms">Matching Algorithms</a><a id="Matching-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Matching-Algorithms" title="Permalink"></a></h2><p>The given-goal proof definition requires one to apply inference rules repeatedly. These inference rules take the form of a set of expressions which, when matched to a subset of the statements in a given section of a proof, the <a href="internals/@ref"><code>conclusion</code></a> part of the inference rule becomes the logical consequence of that subset of given statements.</p><article class="docstring"><header><a class="docstring-binding" id="Deductive.rule_matches" href="#Deductive.rule_matches"><code>Deductive.rule_matches</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rule_matches(ir::InferenceRule, haystack::Set{T}) where {T &lt;: AbstractExpression}</code></pre><p>Computes a vector of matches in which each element is a valid set of possible symbol values, with the catch being that any two sets drawn from different elements of the output vector may or may not be compatible. It is not recommended that this function be used externally. Instead, see <a href="#Deductive.rule_combinations"><code>rule_combinations</code></a>, which outputs a more usable form of rule match, which instead enumerates over all possible matches. Although informationally identical, <a href="#Deductive.rule_combinations"><code>rule_combinations</code></a> is usually preferable due to its linearly iterable ouptut.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ctrekker/Deductive.jl/blob/4b0dd6ee98b6e2afa555dfe3bcf769e4446552ba/src/assertion_proof.jl#L95-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Deductive.rule_combinations" href="#Deductive.rule_combinations"><code>Deductive.rule_combinations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rule_combinations(rule_variables::Set{LogicalSymbol}, reduced_symbol_maps::Vector{Set{SymbolMap}}, current_symbol_map=SymbolMap())</code></pre><p>Given a set of variables which all valid combinations must map to and a list of symbol map sets, compute the set of valid combinations of these symbol maps. In most cases this signature should be avoided in favor of the rule_combinations implementation which directly takes an inference rule and set of expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ctrekker/Deductive.jl/blob/4b0dd6ee98b6e2afa555dfe3bcf769e4446552ba/src/assertion_proof.jl#L128-L134">source</a></section><section><div><pre><code class="nohighlight hljs">rule_combinations(ir::InferenceRule, haystack::Set{T}) where {T &lt;: AbstractExpression}</code></pre><p>Find all valid symbol substitutions which can be performed on a set of statements by an inference rule.</p><p><strong>Examples</strong></p><p>The following code demonstrates that modus ponens can be applied on this set of statements by taking a → b to be true and uses this to imply c. Since the rule for modus ponens is stated with the inference rule (p, p → q) ⊢ q, the  variable substitutions corresponding to the logic above would be <code>p =&gt; a → b</code> and <code>q =&gt; c</code>.</p><pre><code class="language-julia hljs">@symbols a b c
modus_ponens = rule_by_name(PropositionalCalculus, &quot;Modus Ponens&quot;)
my_premises = Set{AbstractExpression}([
    a → b,
    (a → b) → c
])

rule_combinations(modus_ponens, my_premises)
#= Results in:
Set with 1 element:
  Dict(q =&gt; c, p =&gt; a → b)
=#</code></pre><p>Similarly we inspect an example where multiple possible variable substitutions exist. The rule for double negation introduction is defined as p ⊢ ¬¬p, which can apply universally to all statements in a set of premises.</p><pre><code class="language-julia hljs">@symbols a b
double_negation = rule_by_name(PropositionalCalculus, &quot;Double Negation Introduction&quot;)
my_premises = Set{AbstractExpression}([
    a,
    b,
    a ∧ b
])

rule_combinations(double_negation, my_premises)
#= Results in:
Set with 3 elements:
  Dict(p =&gt; a ∧ b)
  Dict(p =&gt; a)
  Dict(p =&gt; b)
=#</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ctrekker/Deductive.jl/blob/4b0dd6ee98b6e2afa555dfe3bcf769e4446552ba/src/assertion_proof.jl#L155-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Deductive.is_partner_map" href="#Deductive.is_partner_map"><code>Deductive.is_partner_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_partner_map(sym_map::SymbolMap, compare_sym_map::SymbolMap)</code></pre><p>Checks whether <code>sym_map</code> and <code>compare_sym_map</code> are &quot;partner maps&quot;. Two symbol maps are partners if they do not form any contradictions between their intersection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ctrekker/Deductive.jl/blob/4b0dd6ee98b6e2afa555dfe3bcf769e4446552ba/src/assertion_proof.jl#L76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Deductive.has_partner_map" href="#Deductive.has_partner_map"><code>Deductive.has_partner_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_partner_map(sym_map::SymbolMap, compare_sym_map_set::Set{SymbolMap})</code></pre><p>Checks whether <code>sym_map</code> has a single partner in the set <code>compare_sym_map_set</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ctrekker/Deductive.jl/blob/4b0dd6ee98b6e2afa555dfe3bcf769e4446552ba/src/assertion_proof.jl#L85-L89">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../proof_utilities/">« Proof Utilities</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.11 on <span class="colophon-date" title="Saturday 22 January 2022 03:06">Saturday 22 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
